# -*- coding: utf-8 -*-
"""simulated_annealing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MqItwZUAnDxFsr-qBRvHFP4nMpcyBupc
"""

import matplotlib.pyplot as plt
import random
import math
import json
import tsplib95

path_to_data = './benchmark_dataset/'

def acceptance_function(del_E,Temperature):
    if del_E < 0:
        return 1
    else:
        random_number = random.uniform(0, 1)
        if(random_number < math.exp(-del_E/Temperature)):
            return 1
        else:
            return 0

def path_cost(path, roads):
    return sum(roads[path[k-1]][path[k]] for k in range(len(path)))

def simulated_annealing(cities, roads, T_min = 0.00000001, cost_threshold = 0,cooling_rate = 0.9999995):
    Temperature = int(1e8)
    path = [0] + random.sample(range(1, cities), cities - 1) + [0]
    cost = path_cost(path, roads)
    while Temperature > T_min and cost > cost_threshold :
        i,j = sorted(random.sample(range(1, cities), 2))
        new_path = path[:i] + path[i:j+1][::-1] + path[j+1:]
        new_cost = path_cost(new_path, roads)
        change_in_cost = new_cost - cost
        if acceptance_function(change_in_cost, Temperature):
            path, cost = new_path, new_cost
        Temperature *= cooling_rate

    return path, cost

def distance(i,j):
  x1,y1 = i[0],i[1]
  x2,y2 = j[0],j[1]
  return math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))

def get_matrix(tsp_data):
  nodes = tsp_data.node_coords
  size = tsp_data.dimension
  adj_matrix = []
  for i in range(size):
    adj_matrix.append([])
    for j in range(size):
      adj_matrix[i].append(distance(nodes[i+1],nodes[j+1]))

  return adj_matrix

def plot_tsp(nodes,path,name):
  x = [nodes[i+1][0] for i in range(len(nodes))]
  y = [nodes[i+1][1] for i in range(len(nodes))]
  plt.plot(x, y, 'o', markersize=1, color='blue', label='Cities')
  # Plot the connections between cities in the solution path
  for i in range(len(path)-1):
      start_x, start_y = nodes[path[i]+1][0],nodes[path[i]+1][1]
      end_x, end_y = nodes[path[i+1]+1][0],nodes[path[i+1]+1][1]
      plt.plot([start_x, end_x], [start_y, end_y], '-', color='red', alpha=0.7)

  # Add labels and title
  plt.xlabel('X-coordinate')
  plt.ylabel('Y-coordinate')
  plt.title(name+' TSP Solution Path')

  # Customize plot (optional)
  plt.legend()
  plt.grid(True)

  plt.show()

opt = [1,
47,
93,
28,
67,
58,
61,
51,
87,
25,
81,
69,
64,
40,
54,
2,
44,
50,
73,
68,
85,
82,
95,
13,
76,
33,
37,
5,
52,
78,
96,
39,
30,
48,
100,
41,
71,
14,
3,
43,
46,
29,
34,
83,
55,
7,
9,
57,
20,
12,
27,
86,
35,
62,
60,
77,
23,
98,
91,
45,
32,
11,
15,
17,
59,
74,
21,
72,
10,
84,
36,
99,
38,
24,
18,
79,
53,
88,
16,
94,
22,
70,
66,
26,
65,
4,
97,
56,
80,
31,
89,
42,
8,
92,
75,
19,
90,
49,
6,
63]
opt = [x-1 for x in opt]+[opt[0]-1]

import time

def main():
    file = 'kroA100.tsp'
    tsp_data = tsplib95.load(path_to_data+file)
    cities = tsp_data.node_coords
    roads = get_matrix(tsp_data)
    start = time.time()
    path, cost = simulated_annealing(len(cities), roads)
    end = time.time()
    print('Time: ',end-start,'s')
    print('cost: ',cost)
    plot_tsp(cities,path,'Our')

    opt_cost = path_cost(opt,roads)
    print('optimum: ', opt_cost)
    plot_tsp(cities,opt,'Optimal')

    print('percentage opt: ',((cost-opt_cost)/opt_cost)*100,'%')

main()

